# 配送料金チェックアプリ
## そのパターンの用途・どんなケースに適用できるか
- テンプレートメソッドパターンを、インスタンス生成の場面に応用したもの。
- インスタンスの作り方をスーパークラスで定めるが、どのクラスのインスタンスを生成するかはサブクラス側で定義するというもの。
    - これにより、スーパークラスは具体的なクラス名に束縛されなくなる。

### ポイント
- 新たな種類の Product を扱いたい場合、ConcreteProduct と ConcreteCreator を作るだけで良く、スーパークラスの Product・Creator 側は何も変更しなくて済む。
- Creator役の createProductメソッド（サンプルでは CreateDeliveryメソッド）は、以下の3つの実装方法がある
    - 抽象メソッドにする（サンプルもこの方式）
    - デフォルトの実装を用意しておく
    - エラーにする
- ConcreteCreator は基本的にひとつインスタンスをつくれば良いため（インスタンスごとに固有のデータを持つようなものではない）、Singletonパターンで実装することが多い。

### 作成したサンプルの概要説明
### ソースコードの説明
[クラス図_04_FactoryMethodPattern](https://app.diagrams.net/#G1tgGOTJkjeALWFz7hoxEG2k6krkbFmu5A#%7B%22pageId%22%3A%22SImt-kA3hvNWynnzsYsr%22%7D)

### プログラムの実行結果
```
===== 12 * 20 * 6 の荷物 ======
【ヤマト】プラン：宅急便（750円）
【日本郵便】プラン：ゆうパケットプラス（450円）
===== 5 * 6 * 2 の荷物 =====
【ヤマト】プラン：ネコポス（210円）
【日本郵便】プラン：ゆうぱけっと（215円）
```

### 疑問点
- Creator役でCreateメソッドをテンプレートメソッドとして定めているため、Createメソッドに渡す引数の数やデータ型などは全てのConcreteCreatorで共通にできるようなケースにしか使えないのではないか。前回のケースだと、TimesStartTemplateは引数なし、PRTemplateは引数2つ（タイトルとIssueのID）をもらう実装だった。その場合、呼び出し側で Createメソッドに渡す引数を変える必要があり、Createメソッドをテンプレートメソッドとして定義できないのではないか？
    - → 確かにそう。実際には、このデメリットを補うためにFactoryMethod単体ではなくほかのパターンとの組み合わせで使われることが多い。
- このパターンのメリットとして、FrameworkパッケージがDeliveryCompanyパッケージに依存しなくなることを挙げていた。今回の例では FrameworkパッケージにはFactoryMethodPatternを実現するために必要なロジックしか含まれていないためあまり大きなメリットを感じられなかったが、本来はFrameworkパッケージ側に他の多くの業務ロジックが組み込まれる形になる？
    - FrameworkをgemやRails本体と捉えると、FrameworkはRailsの中身であるため変えられない、gemも変えられない。しかし、アプリ側は変えられる。Frameworkがアプリに依存しなくなることにより、Framework側を変更できなくてもアプリ側の変更だけでなんとかなる。だれかまた他の人がSagawaを作っても、フレームワーク側・アプリでの呼び出し側も変えなくて済む。
- 住所を扱う必要が出てきた場合は？
    - Frameworkの範囲を超えてしまっているため、Framework をそもそも拡張する必要が出てくる。Frameworkの範囲内であれば、サブクラスをつくることで対応できる。

# 課題
- Mainメソッドの中身をクラスや関数に分割し、フレームワーク（「AssignPlan→CalcPrice→比較」のようにDelveryを使う手順）・アプリ・gemに分割する。
    - フレームワークについては、Framework.Famework.cs にロジックを書くイメージ。